/*
L1-7 整除光棍
这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。

提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。

输入格式：
输入在一行中给出一个不以5结尾的正奇数x（<1000）。

输出格式：
在一行中输出相应的最小的s和n，其间以1个空格分隔。
*/

#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n = 1;  // n表示光棍数的位数（全1的个数）
    unsigned long long x, s = 0; cin >> x;
    
    // 第一步：找到能被x整除的最小光棍数的位数
    unsigned long long t = 1 % x;  // t保存余数
    while (t != 0)  // 当余数不为0时继续
    {
        n++;
        // 关键：利用模运算性质 (a*10 + 1) % x = ((a%x)*10 + 1) % x
        // 避免了大数运算，每次只需保存余数
        t = (t * 10 + 1) % x;
    }
    
    // 第二步：模拟竖式除法，求出商（即s）
    string ans = "";  // 用字符串存储商，避免大数问题
    int curr = 0;     // curr保存当前步骤的被除数
    for (int i = 1; i <= n; i++)
    {
        curr = curr * 10 + 1;  // 每次在末尾加1
        ans += to_string(curr / x);  // 将当前位的商加入结果
        curr %= x;  // 保存余数供下一步使用
    }
    
    // 第三步：处理前导零并输出结果
    int len = ans.size();
    bool afterZero = false;  // 标记是否遇到第一个非零数字
    for (int i = 0; i < len; i++)
    {
        // 跳过前导零
        if (!afterZero && ans[i] != '0') afterZero = true;
        if (afterZero) cout << ans[i];
    }
    cout << ' ' << n << endl;  // 输出光棍数的位数
    return 0;
}