/*
#P6625. [省选联考 2020 B 卷] 卡牌游戏

轩轩某天想到了一个卡牌游戏，游戏规则如下：

初始时轩轩的手中有自左向右排成一排的 n 张卡牌，每张卡牌上有一个整数分值。
接下来，轩轩每次可以选取卡牌序列最左边的连续若干张卡牌（至少 2 张），
将它们替换为一张新卡牌。新卡牌将插入到序列的最左端，
它的分值为本次操作中被替换掉的卡牌的分值之和。

初始时轩轩总分为 0，每执行一次卡牌替换操作，新卡牌的分值将加到总分中。
当序列长度为 1 时游戏结束，轩轩也可以在任意时刻结束游戏。
现在给出序列中各个卡牌的分值，请你来帮助轩轩计算他能够获得的最高总分是多少？

输入格式
第一行一个正整数 n，代表卡牌的数目。
接下来一行 n 个以空格分隔的整数，
第 i 个数字 ai 代表自左向右第 i 张卡牌的分值。

输出格式
仅一行一个整数表示答案。

Reflection:
先运用前缀和，找到s[n](n > 1)最大(错误思路)，再次重构数组a，
再次重构前缀和。若前缀和s[n](n > 2) 或者 n <= 1。终止合牌。
错误

逐位检查是否为负数，
情况1：
前两位和为负数，逐位检查和，直至和不小于0，
立即求和然后重构数列。否则不合卡立即结束游戏。
情况2：
前两位和不为负数，立即求和然后重构数列。
复杂

最简单的理解：
就是找怎么加前缀和，才能使和最大！

换个方式
每当找到前缀和大于0的情况就相加，直至找不到位置。
*/

#include <iostream>
using namespace std;

int main()
{
    int n;
    cin >> n;
    
    long long a[n + 1] = {0}, s[n + 1] = {0};
    for (long long i = 1; i <= n; i++)
    {
        cin >> a[i];
        s[i] = a[i] + s[i - 1];
    }

    long long t = 0;

    for (long long i = 2; i <= n; i++)
    {
        if (s[i] >= 0)
        {
            t += s[i];
        }
    }
    
    cout << t;
    return 0;
}

/*

纪念我死去的回忆

#include <iostream>
using namespace std;

int main()
{
    int n;
    cin >> n;
    int a[n + 1] = {0}, s[n + 1] = {0};
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        s[i] = a[i] + s[i - 1];
    }
    int t = 0, p = 2;
    while (p <= n)
    {
        if (s[p] > 0)
        {
            t += s[p];
        }
        else
        {
            int i;
            for (i = p; s[i - 1] < 0 && i <= n; i++)
            {
                if (s[i] > 0)
                    p = i;
            } // 逐位找到和不为零的位置
            if (p != i - 1)
            {
                cout << t;
                return 0;
            } // 后续无法再增加直接结束
            t += s[p];
        }
        p++;
    }

    cout << t;
    return 0;
}
*/