/*
题目描述
某大学有 n 个职员，编号为 1…n。
他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。
现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 ri​，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。
所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

输入格式
输入的第一行是一个整数 n。
第 2 到第 (n+1) 行，每行一个整数，第 (i+1) 行的整数表示 i 号职员的快乐指数 ri。
第 (n+2) 到第 2n 行，每行输入一对整数 l,k，代表 k 是 l 的直接上司。

输出格式
输出一行一个整数代表最大的快乐指数。
*/

/*
    树形dp
*/

#include<bits/stdc++.h> 
using namespace std;

const int N = 6e3 + 5;
vector<int> e[N];
int f[N][2], w[N], fa[N];
int n;

void dfs(int u)
{
    f[u][1] = w[u]; 
    for (int c : e[u])
    {
        dfs(c); // 递归至叶子
        f[u][0] += max(f[c][0], f[c][1]); 
        // 该节点不选有两种选择：
        // 1.选子节点被选择的
        // 2.选子节点不被选择的
        f[u][1] += f[c][0];
        // 选了就莫得选择了
    }
}

int main( )
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
    for (int i = 1; i < n; i++)
    {
        int l, k; cin >> l >> k;
        e[k].push_back(l); fa[l]++;
    }
    int u = 1;
    while (fa[u]) u++;
    dfs(u);
    cout << max(f[u][0], f[u][1]) << endl; // 最终需要选择最大的
    return 0;
}