/*
题目描述

有编号为 1 到 30000 的 30000 艘战舰，初始时第 i 号战舰处于第 i 列。有两种指令：
M i j：将第 i 号战舰所在的战舰队列，作为一个整体（头在前尾在后）接至第 j 号战舰所在的战舰队列的尾部。
C i j：询问第 i 号战舰与第 j 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

输入格式
第一行有一个整数 T（1≤T≤5×105），表示总共有 T 条指令。
以下有 T 行，每行有一条指令。指令有两种格式：
M i j：i 和 j 是两个整数（1≤i,j≤30000），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 i 号战舰与第 j 号战舰不在同一列。
C i j：i 和 j 是两个整数（1≤i,j≤30000），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。

输出格式
依次对输入的每一条指令进行分析和处理：、
如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。
如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 i 号战舰与第 j 号战舰之间布置的战舰数目。如果第 i 号战舰与第 j 号战舰当前不在同一列上，则输出1 -1。
*/

/*
    带权并查集
*/

#include<bits/stdc++.h> 
using namespace std;

const int N = 3e4 + 10;
int fa[N];
int d[N], n[N];

int find(int x)
{
    if (fa[x] == x) return x;
    int fx = find(fa[x]);   // 找到祖先
    d[x] += d[fa[x]];       // 更新其距离
    return fa[x] = fx;      // 合并路径
}

int main( )
{
    int t; cin >> t;
    for (int i = 1; i <= 30000; i++) {fa[i] = i; n[i] = 1; d[i] = 0;}
    while (t--)
    {
        char c; int i, j; cin >> c >> i >> j;
        int fi = find(i), fj = find(j);
        if (c == 'M')
        {
            fa[fi] = fj;    // 更新 i 的祖先
            d[fi] += n[fj]; // 更新fi到祖先的距离
            n[fj] += n[fi]; // 更新fj队列的长度
            n[fi] = 0;      // 更新fi队列的长度
        }
        else
        {
            if (fi != fj) {cout << -1 << endl; continue;}
            int ans = abs(d[i] - d[j]) - 1;
            cout << ans << endl;
        }
    }
    return 0;
}