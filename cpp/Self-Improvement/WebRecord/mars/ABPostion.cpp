/* 问题描述

AB 实验同学每天都很苦恼如何可以更好地进行 AB 实验，每一步的流程很重要，我们目标为了缩短所需的步数。

我们假设每一步对应到每一个位置。从一个整数位置 `x` 走到另外一个整数位置 `y`，每一步的长度是正整数，每步的值等于上一步的值 `-1`， `+0`，`+1`。求 `x` 到 `y` 最少走几步。并且第一步必须是 `1`，最后一步必须是 `1`，从 `x` 到 `y` 最少需要多少步。
*/

#include <iostream>
#include <cmath>

int solution(int x, int y)
{
    // Please write your code here
    int diff = abs(x - y);

    return;
}

int main()
{
    //  You can add more test cases here
    std::cout << (solution(12, 6) == 4) << std::endl;
    std::cout << (solution(34, 45) == 6) << std::endl;
    std::cout << (solution(50, 30) == 8) << std::endl;
    return 0;
}

/*
思路一：先算差，再用等差数列找到中间值的两端 ⨉:有的数字中间可能小于了两边，难以排除
思路二：先算差，再铺平，除了两边每次加1
若偶数：
        1 1 1 1 1 1（6）
        1 2 2 1
        无法再加！
        返回

        1 1 1 1 1 1 1 1 1 1（10）
        1 2 2 2 2 1
        无法相加！
        返回

        1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 （16）
        1 2 2 2 2 2 2 2 1
        1 2 2 3 3 2 2 1
        无法相加！
        返回
        （发现若中间几个数能组成6时，能拆分为两个三）

        1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1（28）
        1 2 2 2 2 2 2 2 2 2 2 2 2 1     (2 + 26)
        1 2 2 2 3 3 2 2 1     (2 + 10 + 6)
        1 2 3 3 3 3 2 1 (2 + 4 + 12)
        无法找到规律qwq
√

该题涉及BFS,Try it later.

*/