/*
给定 n,m。有 n 次计算，每次计算有一个运算符 op（AND、OR、XOR）和一个参数 ti。初始值为 x0，范围是 [0, m]。
每次计算前之前被计算值为 x，计算后被计算值变为 x op ti。
求最终得到最大的计算值。

AND 表示按位与，OR 表示按位或，XOR 表示按位异或

输入样例：
3 10
AND 5
OR 6
XOR 7

输出样例：
1

输入数据范围：
n ≤ 10^5
m ≤ 10^9

要解决这个题目，首先需要对位运算有清晰的理解，尤其是 与、或、异或 三种运算的作用：

与运算（AND）：两个位都为 1 时结果为 1，否则为 0。
或运算（OR）：只要有一个位为 1，结果就为 1。
异或运算（XOR）：两个位不同结果为 1，相同结果为 0。

其次，需要认识到位运算的一个重要特性：位运算不会改变数字的二进制长度，即它仅对每一位独立操作，其他位互不干涉。
基于这一特性，我们可以从高位到低位，逐位确定一个数字，使得它在不超过限制（m）的前提下尽可能大：

1.逐位计算是可行的：
    由于每一位的操作独立，不会影响其他位，因此可以贪心地从高位到低位，依次决定当前位的取值。
2.从高位开始确保数字最大：
    高位的权重（影响结果的贡献）远大于低位，每次优先选择当前位的最大可能值，从而保证全局的最优解。

通过这样的思路，我们逐位处理，最终得到一个满足条件且尽可能大的答案。
*/
#include <bits/stdc++.h>
using namespace std;

int a[100005][2];
int n, m;

int calc(int bit, int now)
{
    for (int i = 1; i <= n; i++)
    {
        int x = (a[i][0] >> bit) & 1; // 处理 第i个 数字，进行移位操作，将处理位移至 第0位，然后用 & 取出。
        if (a[i][1] == 0)
            now &= x; // 位运算符为 AND 时
        else if (a[i][1] == 1)
            now |= x; // 位运算符为 OR  时
        else
            now ^= x; // 位运算符为 XOR 时
    }

    return now;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        string temp;
        cin >> temp >> a[i][0];
        if (temp == "AND")
            a[i][1] = 0;
        else if (temp == "OR")
            a[i][1] = 1;
        else
            a[i][1] = 2;
    } // 数据输入

    int val = 0, ans = 0;
    for (int bit = 29; bit >= 0; bit--) // m 的最大值为 10^9，二进制表示最多 30 位，从最高位开始逐位计算
    {
        int res0 = calc(bit, 0);                  // 假如在 第bit位 为0，那结果为......
        int res1 = calc(bit, 1);                  // 假如在 第bit位 为1，那结果为......
        if (val + (1 << bit) <= m && res0 < res1) // 如果此时的数字小于等于m 且 初始为0的结果 大于 初始为1的结果，则一定取 1
            val += 1 << bit, ans += res1 << bit;
        else
            ans += res0 << bit;
    }

    cout << ans << endl;
    return 0;
}