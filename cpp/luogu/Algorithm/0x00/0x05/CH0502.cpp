/*
七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。
于是 TYVJ 今年举办了一次线下七夕祭。
Vani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。
TYVJ 七夕祭和 11 区的夏祭的形式很像。
矩形的祭典会场由 N 排 M 列共计 N×M 个摊点组成。

虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。
Vani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。
不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。
两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。
由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。
现在 Vani 想知道他的两个要求最多能满足多少个。
在此前提下，至少需要交换多少次摊点。

输入格式
第一行包含三个整数 N 和 M 和 T，T 表示 cl 对多少个摊点感兴趣。
接下来 T 行，每行两个整数 x,y，表示 cl 对处在第 x 行第 y 列的摊点感兴趣。

输出格式
首先输出一个字符串。
如果能满足 Vani 的全部两个要求，输出 both；
如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 row；
如果只能使各列中 cl 感兴趣的摊点数一样多，输出 column；
如果均不能满足，输出 impossible。
如果输出的字符串不是 impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。

数据范围
1 ≤ N, M ≤ 100000,
0 ≤ T ≤ min(N ∗ M, 100000),
1 ≤ x ≤ N,
1 ≤ y ≤ M
*/

/*
    一.左右交换，每一行的感兴趣摊位数量不变。
    上下交换，每一行的感兴趣摊位数量不变
    
    目标1：通过最少的左右交换达到每列感兴趣的相同
    目标2：通过最少的上下交换达到每行感兴趣的相同
    两个目标都是单独的，相互之间不会有影响

    将其抽象化为 a[N] 统计每列的兴趣摊位数目
                b[N] 统计每行的兴趣摊位数目
    
    给出数据（0 不感兴趣，1 感兴趣）：
            
            0 1 0 1
            0 0 0 0
            1 0 0 1
            0 0 0 0

    a[0] = 1, a[1] = 1, a[2] = 0, a[3] = 2
    b[0] = 2, b[1] = 0, b[3] = 2, b[3] = 0

    先进行左右交换

            0 1 0 1
            0 0 0 0
            1 0 1 0
            0 0 0 0

    a[0] = 1, a[1] = 1, a[2] = 1, a[3] = 1
    b[0] = 2, b[1] = 0, b[3] = 2, b[3] = 0

    再进行上下交换

            0 1 0 0
            0 0 0 1
            0 0 1 0
            1 0 0 0

    a[0] = 1, a[1] = 1, a[2] = 1, a[3] = 1
    b[0] = 1, b[1] = 1, b[3] = 1, b[3] = 1

    由此可以发现

    上下交换与左右交换时

*/
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int N = 1e5 + 100;
int a[N], b[N];
LL sum[N];

LL find(int *c, int t)
{
    //首先得到平均值
    LL aver = 0;
    for (int i = 1; i <= t; i++) aver += c[i];
    aver /= t;
    for (int i = 1; i <= t; i++) c[i] -= aver, sum[i] = sum[i - 1] + c[i];

    sort(sum + 1, sum + t + 1);
    LL mid = sum[t / 2 + 1];
    
    LL ans = 0;
    for (int i = 1; i <= t; i++) ans += abs(sum[i] - mid);
    return ans;
}

int main()
{
    int n, m, t;
    cin >> n >> m >> t;

    for (int i = 0; i < t; i++)
    {
        int x, y;
        cin >> x >> y;
        a[x]++, b[y]++;
    }
    if (t % n && t % m)
    {
        printf("impossible");
    }
    else if (t % n && !(t % m))
    {
        printf("column %lld", find(b, m));
    }
    else if (!(t % n) && t % m)
    {
        printf("row %lld", find(a, n));
    }
    else
    {
        printf("both %lld", find(a, n) + find(b, m));
    }

    return 0;
}